import re
from groq import Groq 
client = Groq(api_key=os.environ.get("GROQ_API_KEY"))
def call_groq_llm_to_merge_tables(table_fragments_and_context):
    """
    Sends table fragments and surrounding context to Groq for merging.

    Args:
        table_fragments_and_context (str): A string containing Markdown table
                                          fragments and any relevant surrounding text.

    Returns:
        str: The merged Markdown table as generated by the LLM.
    """
    prompt = f"""
    You are an expert at identifying and merging Markdown tables.
    The following text contains Markdown table fragments that are likely part of a single table broken across pages.
    Please merge these fragments into a single, complete, and correctly formatted Markdown table.
    Maintain all data, accurately align columns, and handle any differences in column count by padding rows with empty cells where needed.
    Ensure the output is a valid Markdown table.
    If the text contains multiple unrelated tables, please return them as separate, valid Markdown tables. 

    Text to merge:
    {table_fragments_and_context}
    """

    try:
        chat_completion = client.chat.completions.create(
            messages=[
                {
                    "role": "user",
                    "content": prompt,
                }
            ],
            # Adjust the model based on your needs and Groq's available models
            model="llama3-8b-8192",  # Example model, consider others like llama3-70b-8192
            temperature=0.0, # Lower temperature for more deterministic outputs
            max_tokens=4000, # Adjust based on expected table size and LLM context window
        )
        return chat_completion.choices[0].message.content
    except Exception as e:
        print(f"Error calling Groq LLM: {e}")
        return table_fragments_and_context # Return original if LLM call fails
def merge_fragmented_markdown_tables(md_filepath, output_filepath=None):
    """
    Reads a Markdown file, identifies fragmented tables, merges them,
    and writes the result to a new file or updates the original.

    Args:
        md_filepath (str): The path to the input Markdown file.
        output_filepath (str, optional): The path to the output Markdown file.
                                         If None, the input file will be overwritten.
                                         Defaults to None.
    Returns:
        bool: True if tables were merged successfully, False otherwise.
    """
    try:
        with open(md_filepath, 'r', encoding='utf-8') as f:
            content = f.read()

        # Regex to capture markdown tables: header, separator, and rows
        # This pattern captures the full table including header, separator line, and data rows.
        # It's flexible enough to handle various alignment styles in the separator line.
        # It also handles tables that might have empty lines between rows or a trailing blank line.
        table_pattern = re.compile(
            r'(?:^.*\|.*\|.*$\n?)+',  # Matches one or more lines with at least two pipes
            re.MULTILINE
        )
        
        # Find all table matches and their starting/ending indices
        matches = list(table_pattern.finditer(content))

        if not matches:
            print("No Markdown tables found in the file.")
            return False

        merged_content_parts = []
        last_end = 0

        # Iterate through the matches to identify and merge fragmented tables
        i = 0
        while i < len(matches):
            current_match = matches[i]
            current_table_str = current_match.group(0).strip()
            merged_table_rows=call_groq_llm_to_merge_tables(current_table_str)
            #current_table_lines = current_table_str.split('\n')
            
            # Extract header and separator from the current table
            #current_header = current_table_lines[0]
            #current_separator = current_table_lines[1]

            # Add content before the current table
            merged_content_parts.append(content[last_end:current_match.start()])

            #merged_table_rows = current_table_lines[2:]  # Initial rows of the first fragment 
            # Reconstruct the merged table
            merged_table_str = ''.join(merged_table_rows)
            merged_content_parts.append(merged_table_str)
            last_end = current_match.end()
            i +=1
        # Add any remaining content after the last table
        merged_content_parts.append(content[last_end:])

        final_merged_content = ''.join(merged_content_parts)
        print(final_merged_content)

        # Write the merged content to the output file
        if output_filepath:
            with open(output_filepath, 'w', encoding='utf-8') as f:
                f.write(final_merged_content)
            print(f"Merged tables and saved to {output_filepath}")
        else:
            with open(md_filepath, 'w', encoding='utf-8') as f:
                f.write(final_merged_content)
            print(f"Merged tables and updated {md_filepath}")

        return True

    except FileNotFoundError:
        print(f"Error: File not found at {md_filepath}")
        return False
    except Exception as e:
        print(f"An error occurred: {e}")
        return False

# Usage:
input_md_file = "/home/ritik-intel/Aayush/tender-eval/comps/dataprep/out/control-center-bid-1/control-center-bid-1.md"
output_md_file = "/home/ritik-intel/Aayush/tender-eval/comps/dataprep/out/control-center-bid-1/output_merged.md"
merge_fragmented_markdown_tables(input_md_file,output_md_file)



